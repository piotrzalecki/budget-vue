Ticket — “useSnackbar composable”

(Epic 8 – State & Composables, shared utility)

useSnackbar() centralises all toast / alert messaging so every component shows notifications in the same way, through the single <v-snackbar> already mounted in App.vue.

Why we need it	Outcome
Consistent UX	All success/error/info messages appear in one place, with uniform colours and timeout.
Decoupled code	Components don’t import Vuetify objects directly—just call a tiny helper.
Queueing	Composable can queue messages so multiple toasts don’t overlap.
Testable	In unit tests you can spy on snackbar.push() instead of inspecting DOM.


⸻

1 Implementation

// src/composables/useSnackbar.ts
import { reactive } from 'vue'

type Level = 'success' | 'error' | 'info' | 'warning'

interface SnackState {
  show:  boolean
  msg:   string
  color: Level
  queue: { msg: string; color: Level }[]
  timeout: number
}

const state: SnackState = reactive({
  show: false,
  msg:  '',
  color: 'info',
  queue: [],
  timeout: 3000
})

function next() {
  if (state.queue.length && !state.show) {
    const { msg, color } = state.queue.shift()!
    state.msg   = msg
    state.color = color
    state.show  = true
  }
}

export function useSnackbar() {
  /** Push a new toast */
  function push(msg: string, color: Level = 'info', timeout = 3000) {
    state.queue.push({ msg, color })
    state.timeout = timeout
    next()
  }

  /** Call in <v-snackbar @update:show> to pop current and show next */
  function onHide() {
    state.show = false
    next()
  }

  return { ...toRefs(state), push, onHide }
}


⸻

2 App-level mounting

<!-- App.vue -->
<v-snackbar
  v-model="snack.show"
  :timeout="snack.timeout"
  :color="snack.color"
  @update:show="snack.onHide"
>
  {{ snack.msg }}
</v-snackbar>

// App.vue <script setup>
import { useSnackbar } from '@/composables/useSnackbar'
const snack = useSnackbar()


⸻

3 Using it in components / stores

import { useSnackbar } from '@/composables/useSnackbar'
const snack = useSnackbar()

async function save() {
  try {
    await api.post('/transactions', data)
    snack.push('Transaction added', 'success')
  } catch (e) {
    snack.push('Failed to save', 'error', 5000)
  }
}


⸻

4 Unit test outline (Vitest)

it('queues and shows messages', () => {
  const s = useSnackbar()
  s.push('hello', 'info')
  expect(s.show.value).toBe(true)
  expect(s.msg.value).toBe('hello')
  s.onHide()          // simulate snackbar close
  expect(s.show.value).toBe(false)
})


⸻

5 Acceptance criteria
	•	Any call to snack.push() instantly shows a toast; multiple rapid calls queue.
	•	Snackbar colours map to theme (success green, error red, etc.).
	•	Closing one toast auto-displays the next.
	•	No component directly creates <v-snackbar>—all go through the composable.
	•	Unit tests for basic queue/colour logic pass in CI.

When these behaviours are implemented and adopted across pages, the “useSnackbar composable” ticket is complete.